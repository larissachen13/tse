http://old-www.cs.dartmouth.edu/~cs50/Lectures/03-shellcontinued.html
3
<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lecture 03 - More about Bash</title>
  <meta name="description" content="In Computer Science 50 you will learn how to design & build large,  reliable, maintainable, and understandable software systems.  In the process you will learn to program in C with Unix development tools.
">

  <link rel="stylesheet" href="/~cs50/css/main.css">
  <link rel="canonical" href="http://www.cs.dartmouth.edu/~cs50/Lectures/03-shellcontinued.html">
</head>


  <body>

    <header class="site-header">

    <a class="site-title" href="/~cs50/">CS50 Summer 2016</a>

    <nav class="site-nav">

      [<a href="https://canvas.dartmouth.edu/courses/15260">Canvas</a>]
      [<a href="https://piazza.com/dartmouth/summer2016/cs50/home">Piazza</a>]
      [<a href="https://gitlab.cs.dartmouth.edu">Gitlab</a>]
      [<a href="/~cs50/Schedule.pdf">Schedule</a>]
      [<a href="/~cs50/Lectures/">Lectures</a>]
      [<a href="/~cs50/Reading/">Reading</a>]
<!--      [<a href="/~cs50/examples/">Examples</a>]  -->
      [<a href="/~cs50/Logistics/">Logistics</a>]
      [<a href="/~cs50/Resources/">Resources</a>]
      [<a href="/~cs50/Labs/">Labs</a>]
      [<a href="/~cs50/Project/">Project</a>]

   </nav>
</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Lecture 03 - More about Bash</h1>
  </header>

  <div class="post-content">
    <p>Don’t forget this week’s <a href="/~cs50/Reading/#week-1">reading</a>.</p>

<p>In this lecture, we continue our discussion of the Unix shell and its commands.</p>

<!-- 
> See the [typescript](03-shellcontinued-script.txt) of my in-class demo (only those portions in the cs50@flume window). *This typescript was automatically captured but hand-edited to clean it for readability, and I may have made some mistakes.* -->

<h3 id="goals">Goals</h3>

<p>We plan to learn the following today:</p>

<ul>
  <li>Redirection and pipes</li>
  <li>Special characters and quoting</li>
  <li>Standard input, output, and error</li>
  <li>Printing</li>
  <li>Compressing and archiving files</li>
</ul>

<h2 id="redirection-and-pipes">Redirection and pipes</h2>

<p>To date we have seen Unix programs using default input and output - called <em>standard input</em> (stdin) and <em>standard output</em> (stdout) - the keyboard is the standard input and the display the standard output. The Unix shell is able to redirect both the input and output of programs. As an example of output redirection consider the following.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>date &gt; listing
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls -lR public_html/ &gt;&gt; listing
</code></pre>
</div>

<p>The output redirection <code class="highlighter-rouge">&gt;</code> writes the output of <code class="highlighter-rouge">date</code> to the file called <code class="highlighter-rouge">listing</code>; that is, the ‘standard output’ of the <code class="highlighter-rouge">date</code> process has been directed to the file instead of the default, the display.  Note that the <code class="highlighter-rouge">&gt;</code> operation created a file that did not exist before the output redirection command was executed.  Next, we append a recursive, long-format directory listing to the same file; by using the <code class="highlighter-rouge">&gt;&gt;</code> (double <code class="highlighter-rouge">&gt;</code>) we tell the shell to <em>append</em> to the file rather than overwriting the file.</p>

<p>The shell also supports input redirection. This provides input to a program (rather than the keyboard). Let’s create a file of prime numbers using output redirection. The input to the <code class="highlighter-rouge">cat</code> command can come from the standard input (i.e., the keyboard). We can instruct the shell to redirect the <code class="highlighter-rouge">cat</code> command’s output (stdout) to file named <code class="highlighter-rouge">primes</code>. The numbers are input at the keyboard and <code class="highlighter-rouge">CTRL-D</code> is used to signal the end of the file (<code class="highlighter-rouge">EOF</code>).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cat &gt; primes
61
53
41
2
3
11
13
18
37
5
19
23
29
31
47
53
59
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span> 
</code></pre>
</div>

<p>Input redirection <code class="highlighter-rouge">&lt;</code> tells the shell to use a file as input to the command rather than the keyboard. In the input redirection example below <code class="highlighter-rouge">primes</code> is used as input to <code class="highlighter-rouge">cat</code> which sends its standard output to the screen.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cat &lt; primes
61
53
41
2
3
11
13
18
37
5
19
23
29
31
47
53
59
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>Many Unix commands (e.g., <code class="highlighter-rouge">cat</code>, <code class="highlighter-rouge">sort</code>) allow you to provide input from stdin if you do not specify a file on the command line. For example, if you type <code class="highlighter-rouge">cat (CR)</code> (carriage return) then the command expects input from the standard input.</p>

<p>Unix also supports a powerful ‘pipe’ operator for passing data between commands using the operator <code class="highlighter-rouge">|</code> (a vertical bar, usually located above the <code class="highlighter-rouge">\</code> key on your keyboard). Pipes connect commands that run as separate processes as data becomes available the processes are scheduled.</p>

<blockquote>
  <p>Pipes were invented by Doug McIlroy while he was working with Ken Thompson and Dennis Ritchie at AT&amp;T Bell Labs.  (As I mentioned earlier, Doug has been an adjunct professor here at Dartmouth College for several years now.)  In this <a href="/~cs50/Reading/DougMcIlroy.pdf">two-page interview</a>, at the middle of the third column, Doug tells how pipes were invented and the <code class="highlighter-rouge">|</code> character selected as the operator.  Pay special attention to the next paragraph: the Dartmouth Time Sharing System had something similar, even earlier!</p>
</blockquote>

<p>Pipes are a clever invention indeed, since the need for separate temporary files for sharing data between processes is not required. Because commands are implemented as processes, a program reading an empty pipe will be ``suspended’’ until there is data or information ready for it to read. There is no limit to the number of programs or commands in the pipeline. In our example below there are four programs in the pipeline all running simultaneously waiting on the input:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>sort -n primes | uniq | grep -v 18 | more
2
3
5
11
13
19
23
29
31
37
41
47
53
59
61
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>What is the difference between pipes and redirection? Basically, redirection (<code class="highlighter-rouge">&gt;</code>,<code class="highlighter-rouge">&gt;&gt;</code>,<code class="highlighter-rouge">&lt;</code>) is used to direct the stdout of command to a file, or from a file to the stdin of a command. Pipes (<code class="highlighter-rouge">|</code>) are used to redirect the stdout to the stdin of another command. This operator allows us to ‘glue’ together programs as ‘filters’ to process the plain text sent between them (<em>plain text</em> between the processes - a nice design decision). This supports the notion of reuse and allows us to build sophisticated programs quickly and simply. It’s another cool feature of Unix.</p>

<p>Notice three new commands above: <code class="highlighter-rouge">sort</code>, <code class="highlighter-rouge">uniq</code>, and <code class="highlighter-rouge">grep</code>.</p>

<ul>
  <li><code class="highlighter-rouge">sort</code> reads lines from from stdin and outputs the lines in sorted order; here <code class="highlighter-rouge">-n</code> tells `sort to use numeric order (rather than alphabetical order);</li>
  <li><code class="highlighter-rouge">uniq</code> removes duplicates, printing only one of a run of identical lines;</li>
  <li><code class="highlighter-rouge">grep</code> prints lines matching a pattern (more generally, a <em>regular expression</em>); here, <code class="highlighter-rouge">-v</code> inverts this behavior: print lines that <em>do not</em> match the pattern.  In this case, the pattern is simply <code class="highlighter-rouge">18</code> and <code class="highlighter-rouge">grep</code> does not print that number as it comes through.</li>
</ul>

<p>And, as we saw last time, <code class="highlighter-rouge">more</code> pauses the output when it would scroll off the screen.</p>

<p>Note that the original file - <code class="highlighter-rouge">primes</code> - is not changed by executing the command line above. Rather, the file is read in by the <code class="highlighter-rouge">sort</code> command and the data is manipulated as it is processed by each stage of the command pipe line. Because <code class="highlighter-rouge">sort</code> and <code class="highlighter-rouge">cat</code> are happy to read its input data from stdin, or from a file given as an argument, the following pipelines all achieve the same result:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>sort -n &lt; primes       | uniq | grep -v 18 | more
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cat   primes | sort -n | uniq | grep -v 18 | more
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cat &lt; primes | sort -n | uniq | grep -v 18 | more
</code></pre>
</div>

<p>Which do you think would be most efficient?</p>

<p><strong>Another pipeline</strong>: How did I create that list of existing usernames, for Lab0?</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cut -d : -f 1 /etc/passwd | sort &gt; usernames.txt
</code></pre>
</div>

<blockquote>
  <p>See <code class="highlighter-rouge">man cut</code> to understand what the first command does.</p>
</blockquote>

<p><strong>Another example</strong>: what is the most popular shell?  Try each of these in turn:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cut -d : -f 7 /etc/passwd
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cut -d : -f 7 /etc/passwd | less
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cut -d : -f 7 /etc/passwd | sort 
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cut -d : -f 7 /etc/passwd | sort | uniq -c
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cut -d : -f 7 /etc/passwd | sort | uniq -c | sort -n
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cut -d : -f 7 /etc/passwd | sort | uniq -c | sort -nr
</code></pre>
</div>

<h3 id="macos-tip">MacOS tip:</h3>

<p>There are three great commands you should know - they are not on Linux, because they interact with MacOS: <code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">pbpaste</code>, <code class="highlighter-rouge">pbcopy</code>.</p>

<p>You’ve already seen the <code class="highlighter-rouge">open</code> command, which on MacOS at the Terminal command line, will open a file for viewing in the relevant MacOS application; for example, for a photo file you might type <code class="highlighter-rouge">open photo.jpg</code> and see Preview launch and open that file; for an html file you might type <code class="highlighter-rouge">open index.html</code> and see Safari launch and render that page.</p>

<p>The commands <code class="highlighter-rouge">pbpaste</code> and <code class="highlighter-rouge">pbcopy</code> are a great fit into many pipelines.  The first command prints the MacOS ‘clipboard’ to its standard output, and the second copies its standard input into the MacOS clipboard.  For example; select some text in a window somewhere, then <em>cmd-C</em> to copy it to the clipboard, then
<code class="highlighter-rouge">
	pbpaste | wc
</code>
to count the lines, words, and characters in the clipboard.
Or, 
<code class="highlighter-rouge">
	ls -l | pbcopy
</code>
saves the directory listing in the clipboard, where you might paste it into Piazza or an email message or some document.</p>

<p>I’m not certain these will always work on the same command line, however; if you wanted to <em>replace</em> the clipboard with a count of lines, words, and characters, you might try
<code class="highlighter-rouge">
	pbpaste | wc | pbcopy
</code>
but be careful mixing those two commands.</p>

<h2 id="standard-input-output-and-error">Standard input, output and error</h2>

<p>As we learned above, every process (a running program) has a <em>standard input</em> (abbreviated to <code class="highlighter-rouge">stdin</code>) and a <em>standard output</em> (<code class="highlighter-rouge">stdout</code>).  The shell sets <code class="highlighter-rouge">stdin</code> to the keyboard by default, but the command line can tell the shell to redirect <code class="highlighter-rouge">stdin</code> using <code class="highlighter-rouge">&lt;</code> or a pipe. The shell sets <code class="highlighter-rouge">stdout</code> to the display by default, but the command line can tell the shell to redirect <code class="highlighter-rouge">stdout</code> using <code class="highlighter-rouge">&gt;</code> or <code class="highlighter-rouge">&gt;&gt;</code>, or to a pipe.</p>

<p>Each process also has a <em>standard error</em> (<code class="highlighter-rouge">stderr</code>), which most programs use for printing error messages.  The separation of <code class="highlighter-rouge">stdout</code> and <code class="highlighter-rouge">stderr</code> is important when <code class="highlighter-rouge">stdin</code> is redirected to a file or pipe, because normal output can flow into the file or pipe while error messages reach the user on the screen.</p>

<p>Inside the running process these three streams are represented with numeric <em>file descriptors</em>:</p>

<ul>
  <li><code class="highlighter-rouge">stdin</code> : 0</li>
  <li><code class="highlighter-rouge">stdout</code> : 1</li>
  <li><code class="highlighter-rouge">stderr</code> : 2</li>
</ul>

<p>You can tell the shell to redirect using these numbers; <code class="highlighter-rouge">&gt;</code> is shorthand for <code class="highlighter-rouge">1&gt;</code> and <code class="highlighter-rouge">&lt;</code> is shorthand for <code class="highlighter-rouge">0&lt;</code>.  You can thus redirect the standard error (file descriptor 2) with the symbol <code class="highlighter-rouge">2&gt;</code>.  Suppose I was logged in as <code class="highlighter-rouge">cs50</code> and wanted to make a list of the web files <code class="highlighter-rouge">index.html</code> anywhere in the <code class="highlighter-rouge">cs50</code> account’s home directory tree.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>find ~cs50 -name index.html &gt; pages
find: ‘/net/class/cs50/Archive/src’: Permission denied
find: ‘/net/class/cs50/.emacs.d’: Permission denied
find: ‘/net/class/cs50/private/’: Permission denied
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>I redirected the output of <code class="highlighter-rouge">find</code> to a file called <code class="highlighter-rouge">pages</code> - and indeed that file filled with useful information - but <code class="highlighter-rouge">find</code> printed its error messages to the screen so I could still see them.  Suppose I wanted to capture those errors in a file too:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>find ~cs50 -name index.html &gt; pages 2&gt; errors
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>
<p>The file <code class="highlighter-rouge">errors</code> contains the error messages we saw earlier.</p>

<p>As another alternative, we could ignore the error output entirely by sending it to a place where all characters go and never return!</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>dfk@flume ~]<span class="nv">$ </span>find ~cs50 -name index.html &gt; pages 2&gt; /dev/null
<span class="o">[</span>dfk@flume ~]<span class="nv">$ </span>
</code></pre>
</div>
<p>The file called <code class="highlighter-rouge">/dev/null</code> is a special kind of file - it’s not a file at all, actually, it’s a ‘device’ that simply discards anything written to it.  (If you read from it, it appears to be an empty file.)</p>

<h2 id="special-characters">Special characters</h2>

<p>There are a number of special characters interpreted by the shell - spaces, tabs, wildcard (‘globbing’) characters for filename expansion, redirection symbols, and so forth. Special characters have special meaning and cannot be used as regular characters because the shell interprets them in a special manner. These special characters include:</p>

<p><code class="highlighter-rouge">&amp; ; | * ?  ` " ' [ ] ( ) $ &lt; &gt; { } # / \ ! ~</code></p>

<p>We have already used several of these special characters.  Don’t try to memorize them at this stage. Through use, they will become second nature. We will just give some examples of the ones we have not discussed so far.</p>

<h2 id="quoting">Quoting</h2>

<p>If you need to use one of these special characters as a regular character, you can tell the shell not to interpret it by escaping or quoting it. To <em>escape</em> a single special character, precede it with a backslash <code class="highlighter-rouge">\</code>; earlier we saw how to escape the character <code class="highlighter-rouge">*</code> with <code class="highlighter-rouge">\*</code>. To escape multiple special characters (as in <code class="highlighter-rouge">**</code>), quote each: <code class="highlighter-rouge">\*\*</code>. You can also <em>quote</em> using single quotation marks such as <code class="highlighter-rouge">'**'</code> or double quotation marks such as <code class="highlighter-rouge">"**"</code> - but these have subtlety different behavior.  You might use this form when quoting a filename with embedded spaces: <code class="highlighter-rouge">"Homework assignment"</code>.</p>

<p>You will often need to pass special characters as part of arguments to commands and other programs - for example, an argument that represents a pattern to be interpreted by the command; as happens often with <code class="highlighter-rouge">find</code> and <code class="highlighter-rouge">grep</code>.</p>

<p>There is a situation where single quotes work differently than double quotes. If you use a pair of single quotes around a shell variable substitution (like <code class="highlighter-rouge">$USER</code>), the variable’s value will not be substituted, whereas it would be substituted within double quotes:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$LOGNAME</span><span class="s2"> uses the </span><span class="nv">$SHELL</span><span class="s2"> shell and his home directory is </span><span class="nv">$HOME</span><span class="s2">."</span>
cs50 uses the /bin/bash shell and his home directory is /net/class/cs50.
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'$LOGNAME uses the $SHELL shell and his home directory is $HOME.'</span>
<span class="nv">$LOGNAME</span> uses the <span class="nv">$SHELL</span> shell and his home directory is <span class="nv">$HOME</span>.
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p><strong><em>Example 1.</em></strong>
Double-quotes are especially important in shell scripts, because the variables involved might have been user input (a command-line argument or a keyboard input) or might have be a file name or output of a command; such variables should <em>always</em> be quoted when substituted, because spaces (and other special characters) embedded in the value of the variable can cause confusion.  Thus:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nv">directoryName</span><span class="o">=</span><span class="s2">"Homework three"</span>
...
mkdir <span class="s2">"</span><span class="nv">$directoryName</span><span class="s2">"</span>
mkdir <span class="nv">$directoryName</span>
</code></pre>
</div>

<p>Try it!</p>

<p><strong><em>Example 2.</em></strong>
Escapes and quoting can pass special characters and patterns passed to commands.</p>

<p>Suppose I have a list of email addresses, one per line.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>Andrew.M.Sarroff.GR@dartmouth.edu
Rui.Liu.GR@dartmouth.edu
Maksim.Bolonkin.GR@Dartmouth.edu
Douglas.H.Tallmadge.II.18@dartmouth.edu
Maieda.N.Janjua.17@dartmouth.edu
Hao.Chang.16@dartmouth.edu
James.K.Wang.18@dartmouth.edu
Emma.C.Oberstein.18@dartmouth.edu
</code></pre>
</div>

<p>Some email programs, or websites, require these to be comma-separated.  I can change those newline characters to commas:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>tr <span class="se">\\</span>n ,
Andrew.M.Sarroff.GR@dartmouth.edu
Rui.Liu.GR@dartmouth.edu
Maksim.Bolonkin.GR@Dartmouth.edu
Douglas.H.Tallmadge.II.18@dartmouth.edu
Maieda.N.Janjua.17@dartmouth.edu
Hao.Chang.16@dartmouth.edu
James.K.Wang.18@dartmouth.edu
Emma.C.Oberstein.18@dartmouth.edu
Andrew.M.Sarroff.GR@dartmouth.edu,Rui.Liu.GR@dartmouth.edu,Maksim.Bolonkin.GR@Dartmouth.edu,Douglas.H.Tallmadge.II.18@dartmouth.edu,Maieda.N.Janjua.17@dartmouth.edu,Hao.Chang.16@dartmouth.edu,James.K.Wang.18@dartmouth.edu,Emma.C.Oberstein.18@dartmouth.edu,[cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<blockquote>
  <p>On Unix a single special character called ‘newline’ is what <em>defines</em> the end of one line and the beginning of the next. A common syntax for the newline character, in programming languages, is <code class="highlighter-rouge">\n</code>.  But the <code class="highlighter-rouge">\</code> is special, in bash, so we need to escape it, um, with <code class="highlighter-rouge">\</code>; thus we have <code class="highlighter-rouge">\\n</code>.</p>
</blockquote>

<p>The <code class="highlighter-rouge">tr</code> command filters <code class="highlighter-rouge">stdin</code> to <code class="highlighter-rouge">stdout</code>, translates each instance of the character given in the first argument (<code class="highlighter-rouge">\\n</code>) to the character given in the second argument (<code class="highlighter-rouge">,</code>).  Here, I typed the input on the keyboard, then typed <code class="highlighter-rouge">CTRL-D</code> to tell the system that my input was done; then <code class="highlighter-rouge">tr</code> spit out the translated input - on one very long line that does not end with a newline.  I can then copy-paste that result into the pesky web browser.</p>

<p>Outlook and Microsoft tools want <em>semicolons</em>, not commas; sigh.  But the semicolon is also special to bash; so we must escape it too:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>tr <span class="se">\\</span>n ;
</code></pre>
</div>

<p>On MacOS I can connect the MacOS “Clipboard” to this tool as follows:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>pbpaste | tr <span class="se">\\</span>n ; | pbcopy
</code></pre>
</div>
<p>great!  copy the list of addresses to the clipboard, type that command in the shell, and now the clipboard contains a semicolon-separated list of addresses.</p>

<p><strong><em>Example 3.</em></strong>
An even more powerful filtering tool - the stream editor called <code class="highlighter-rouge">sed</code> - allows you to transform occurrences of one or more patterns in the input file(s):</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>	sed pattern <span class="o">[</span>file]...  
</code></pre>
</div>

<p>For example,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">cd</span> /net/quimby/other-lists
<span class="o">[</span>cs50@flume /net/quimby/other-lists]<span class="nv">$ </span>cat thaw-all
PIs				&lt;nobody@cs&gt;
David Kotz &lt;kotz@cs.dartmouth.edu&gt;
Kevin Fu &lt;kevinfu@umich.edu&gt;
...
Travis Peters		&lt;Travis.W.Peters.GR@Dartmouth.edu&gt;
...
<span class="o">[</span>cs50@flume /net/quimby/other-lists]<span class="nv">$ </span>sed -e /nobody/d -e <span class="s1">'s/\t/ /g'</span> -e <span class="s1">'s/  */ /g'</span> thaw-all
David Kotz &lt;kotz@cs.dartmouth.edu&gt;
Kevin Fu &lt;kevinfu@umich.edu&gt;
...
Travis Peters &lt;Travis.W.Peters.GR@Dartmouth.edu&gt;
...
<span class="o">[</span>cs50@flume /net/quimby/other-lists]<span class="nv">$ </span>sed -e /nobody/d -e <span class="s1">'s/.*&lt;//'</span> -e <span class="s1">'s/&gt;.*/,/'</span> thaw-all
kotz@cs.dartmouth.edu,
kevinfu@umich.edu,
...
Travis.W.Peters.GR@Dartmouth.edu
...
</code></pre>
</div>

<p>The above uses the <code class="highlighter-rouge">-e</code> switch to <code class="highlighter-rouge">sed</code>, which allows one to list more than one pattern on the same command.</p>

<p><strong><em>Example 4.</em></strong></p>

<p>I saved a list of students enrolled in CS50 in the file <code class="highlighter-rouge">~cs50/students</code>.
Each line is of the form <code class="highlighter-rouge">First.M.Last.18@Dartmouth.edu;</code>.</p>

<p>Let’s suppose you all decide to move to Harvard.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>sed s/Dartmouth/Harvard/ students
...
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>sed -e s/Dartmouth/Harvard/ -e <span class="s1">'s/\.[0-9][0-9]//'</span> -e <span class="s1">'s/;$//'</span> students
...
</code></pre>
</div>

<p>The second form removes the dot and two-digit class number, and the trailing semicolon.  Notice how I quoted those patterns from the shell, and even escaped the dot from sed’s normal meaning (dot matches any character) so sed would look for a literal dot in that position.  The dollar <code class="highlighter-rouge">$</code> constrains the semicolon match to happen at the end of the line.</p>

<p>Here’s another fun pipe: count the number of students from each class (leveraging the class numbers in email addresses):</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>tr -c -d 0-9<span class="se">\\</span>n &lt; ~cs50/students | sed <span class="s1">'s/^$/other/'</span>  | sort  | uniq -c | sort -nr
     27 18
     22 19
      9 17
      5 other
      1 16
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>See <code class="highlighter-rouge">man sed</code> or the <a href="http://sed.sf.net/grabbag/tutorials/sedfaq.txt">sed FAQ</a> for more info.</p>

<h2 id="printing-files">Printing files</h2>

<p>Sudikoff has several public printers. The printer is named after the lab (<code class="highlighter-rouge">s001</code>, <code class="highlighter-rouge">s003</code>, etc.) or after the hallway (<code class="highlighter-rouge">s2s</code> means Sudikoff 2nd floor south).  <strong>See the <a href="https://wiki.cs.dartmouth.edu/faq/doku.php/users_faq:linux_printing">printing FAQ</a> for a list of all the printers in Sudikoff.</strong></p>

<p>To print a file to the printer you have to direct the print command to the specific printer. For example:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>lpr -Ps003 mydoc  
</code></pre>
</div>

<h2 id="compressing-and-archiving-files">Compressing and archiving files</h2>

<p>It is often useful to bundle several files into a compressed <em>archive</em> file.  You may have encountered files like this on the Internet - such as <code class="highlighter-rouge">files.zip</code>, <code class="highlighter-rouge">something.tar</code>, or <code class="highlighter-rouge">somethin-else.tgz</code>. Each packs together several files - including directories, creation dates, access permissions, as well as file contents - into one single file.  This is a convenient way to transfer large collections of files.</p>

<p>On Unix it is most common to use the <code class="highlighter-rouge">tar</code> utility (short for tape archive - from back when we used tapes) to create an archive of all the files and directories listed in the arguments and name it to something appropriate.  We often ask <code class="highlighter-rouge">tar</code> to compress the resulting archive  too.</p>

<p>Given a directory <code class="highlighter-rouge">stuff</code>, you can create (<code class="highlighter-rouge">c</code>) a compressed tar archive (aka, a “tarball”), and then list (<code class="highlighter-rouge">-t</code>) its contents.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>mkdir stuff
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">echo</span> &gt; stuff/x
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>tar cfz stuff.tgz stuff
 98.8%
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>tar tfz stuff.tgz
stuff/
stuff/x
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>The command leaves the original directory and files intact.  Notice that <code class="highlighter-rouge">tar</code> has an unconventional syntax for its switches - there is no dash <code class="highlighter-rouge">-</code> before them.</p>

<p>To unpack the archive,</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>tar xfz stuff.tgz 
</code></pre>
</div>

<p>In short, <code class="highlighter-rouge">c</code> for create, <code class="highlighter-rouge">t</code> for type (list), <code class="highlighter-rouge">x</code> for extract.  The <code class="highlighter-rouge">f</code> implies that the next argument is the tarball file name.  The <code class="highlighter-rouge">z</code> indicates that the tarball should be compressed.  By convention, a tarball filename ends in <code class="highlighter-rouge">.tar</code> if not compressed, <code class="highlighter-rouge">.tgz</code> if compressed.</p>

<h2 id="our-top-commands">Our top commands</h2>

<p>We’ve explored almost four dozen shell commands, below (those with *asterisk will be introduced later).  You’ll often need only about half of them.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>    <span class="nb">alias

    </span>cat, <span class="nb">cd</span>, chmod, cp, cut

    date

    <span class="nb">echo</span>, emacs, expr, <span class="nb">exit

    </span>file, find

    gcc, gdb<span class="k">*</span>, git<span class="k">*</span>, grep

    head

    less, <span class="nb">logout</span>, lpr, ls

    make<span class="k">*</span>, man, mkdir, more, mv

    open <span class="o">(</span>MacOS<span class="o">)</span>

    pbpaste, pbcopy <span class="o">(</span>MacOS<span class="o">)</span>

    <span class="nb">pwd

    </span>rm, rmdir

    scp, sed, sort, ssh

    tail, tar, touch, tr

    uniq

    whereis, which

    vi, vim
</code></pre>
</div>

<blockquote>
  <p>In addition, <a href="../Labs/Lab1">Lab 1</a> uses two specialized tools for processing image files, <code class="highlighter-rouge">convert</code> and <code class="highlighter-rouge">exif</code>.</p>
</blockquote>

<h2 id="historical-note">Historical note</h2>

<p>Another important moment in computing history, that happened at Dartmouth!</p>

<p><img src="history-DartmouthAI.jpg" alt="Dartmouth AI conference" /></p>

<p>Can you find the building?</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">CS50 Summer 2016 -- Dartmouth College</h2>

    <p> <font size=-1> 
    	This version of the course is based upon those designed by 
    	Professors Kotz, Palmer, Campbell, and Balkcom. 
	I am deeply indebted to these outstanding educators.
    -- <a href="/~xia/">Xia Zhou</a>
       </font> 
    </p>

  </div>

</footer>


  </body>

</html>
