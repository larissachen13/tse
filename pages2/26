http://old-www.cs.dartmouth.edu/~cs50/Lectures/11-make.html
3
<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lecture 11 - make and Makefiles</title>
  <meta name="description" content="In Computer Science 50 you will learn how to design & build large,  reliable, maintainable, and understandable software systems.  In the process you will learn to program in C with Unix development tools.
">

  <link rel="stylesheet" href="/~cs50/css/main.css">
  <link rel="canonical" href="http://www.cs.dartmouth.edu/~cs50/Lectures/11-make.html">
</head>


  <body>

    <header class="site-header">

    <a class="site-title" href="/~cs50/">CS50 Summer 2016</a>

    <nav class="site-nav">

      [<a href="https://canvas.dartmouth.edu/courses/15260">Canvas</a>]
      [<a href="https://piazza.com/dartmouth/summer2016/cs50/home">Piazza</a>]
      [<a href="https://gitlab.cs.dartmouth.edu">Gitlab</a>]
      [<a href="/~cs50/Schedule.pdf">Schedule</a>]
      [<a href="/~cs50/Lectures/">Lectures</a>]
      [<a href="/~cs50/Reading/">Reading</a>]
<!--      [<a href="/~cs50/examples/">Examples</a>]  -->
      [<a href="/~cs50/Logistics/">Logistics</a>]
      [<a href="/~cs50/Resources/">Resources</a>]
      [<a href="/~cs50/Labs/">Labs</a>]
      [<a href="/~cs50/Project/">Project</a>]

   </nav>
</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Lecture 11 - make and Makefiles</h1>
  </header>

  <div class="post-content">
    <p>In the this lecture, we discuss the GNU <code class="highlighter-rouge">make</code> command for building software systems.  To date, we compile programs (some with multiple source files) into an executable using the <code class="highlighter-rouge">gcc</code> command (or the <code class="highlighter-rouge">mygcc</code> alias). We will not do this anymore - no more issuing <code class="highlighter-rouge">mygcc</code> commands from the command line. The <code class="highlighter-rouge">make</code> command will do the heavy lifting of working out what gets compiled for a program. Once you give it some hints in a file called <code class="highlighter-rouge">Makefile</code>, the <code class="highlighter-rouge">make</code> command automatically works out which parts of a program with multiple source files need to be recompiled or not; then, it issues a set of commands to do the job for you. You will need to write Makefiles (of increasing complexity) for Labs 3-5 and for the project.</p>

<p>For a deeper dive into <code class="highlighter-rouge">make</code>, see the <a href="11x-make.html">lecture extra</a>.</p>

<p>To recap the C preprocessor, see the <a href="08-preprocessorpointers.html">lecture note</a>.</p>

<h2 id="goals">Goals</h2>

<p>We learn the following in today’s lecture:</p>

<ul>
  <li>The <code class="highlighter-rouge">make</code> concept</li>
  <li><code class="highlighter-rouge">Makefile</code> basics</li>
  <li><code class="highlighter-rouge">make</code> command usage</li>
  <li>header files (<code class="highlighter-rouge">.h</code>) and <code class="highlighter-rouge">extern</code> declarations</li>
  <li>Another improvement of the <code class="highlighter-rouge">names</code> program: <a href="/~cs50/examples/names2.c">names2.c</a></li>
</ul>

<h2 id="compiling-c-programs">Compiling C programs</h2>

<p>So far we have been using the <code class="highlighter-rouge">gcc</code> program (or the <code class="highlighter-rouge">mygcc</code> alias) to compile C programs into executable files.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>  mygcc program.c -o program
</code></pre>
</div>

<p>Let’s peek under the hood to see what the compiler toolchain is actually doing.</p>

<h3 id="code-chain-from-c-to-assembler-to-object-to-executable">Code chain: from C to assembler to object to executable</h3>

<p>It takes a lot of work to compile a C program! There are four phases to producing the executable: the preprocessor, the compiler, the assembler, and the linker.</p>

<ul>
  <li>The <em>preprocessor</em> includes the header files indicated by the <code class="highlighter-rouge">#include</code> directives (literally replacing the directive with the header file content), and expands the macros defined using <code class="highlighter-rouge">#define</code> (purely substitution at the text level).</li>
  <li>The <em>compiler</em> (<code class="highlighter-rouge">man gcc</code>) translates C-language code from <code class="highlighter-rouge">.c</code> files into assembly-language code in <code class="highlighter-rouge">.s</code> files.</li>
  <li>The <em>assembler</em> (<code class="highlighter-rouge">man as</code>) translates assembly-language code into machine-language code, in <code class="highlighter-rouge">.o</code> files, using a binary ‘object’ format specific to the type of processor on which it will run.</li>
  <li>The <em>linker</em> (<code class="highlighter-rouge">man ld</code>) combines multiple <code class="highlighter-rouge">.o</code> files and pulls in the necessary bits from libraries (in <code class="highlighter-rouge">.a</code> files that archive bunches of <code class="highlighter-rouge">.o</code> files) that are needed to create the machine executable code. (The Unix linker is called <code class="highlighter-rouge">ld</code>, derived from ‘load’, because this step is sometimes called ‘loading’ for historical reasons.)</li>
</ul>

<p>Normally, <code class="highlighter-rouge">gcc</code> runs all steps transparently, automatically, producing a file that can be directly executed by Unix. In a way, <code class="highlighter-rouge">gcc</code> acts as an overseer to run all the necessary steps from start to finish.</p>

<p>Recall the <a href="/~cs50/examples/names1.c"><code class="highlighter-rouge">names.c</code></a> program in the prior lecture.  I needed the <code class="highlighter-rouge">readLine</code> function from prior examples, but didn’t want to copy it, yet again, into my main program. It was time to set up <code class="highlighter-rouge">readLine</code> as a utility function, that could easily be included in every program where I need it.  I created <code class="highlighter-rouge">readline.c</code> to hold the code, and <code class="highlighter-rouge">readline.h</code> to provide the prototypes and other declarations needed by other C files that want to use the <code class="highlighter-rouge">readLine</code> function. (See end of these lecture notes for more about <code class="highlighter-rouge">.h</code> files.)  This program involves multiple C files, which can all be compiled at once:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>  mygcc names.c readline.c -o names
</code></pre>
</div>

<p>Here, <code class="highlighter-rouge">gcc</code> acts as an overseer, running <code class="highlighter-rouge">gcc</code>, <code class="highlighter-rouge">as</code>, and <code class="highlighter-rouge">ld</code> as needed to produce that executable.  It produces intermediate files <code class="highlighter-rouge">names.s</code> and <code class="highlighter-rouge">names.o</code>, <code class="highlighter-rouge">readline.s</code> and <code class="highlighter-rouge">readline.o</code>, then links them to each other and standard libraries, to produce the <code class="highlighter-rouge">names</code> executable file.  When done, it deletes the intermediate files.</p>

<p>But that tends to be inefficient, if <code class="highlighter-rouge">readline.c</code> never changes and you’re iterating on development of <code class="highlighter-rouge">names.c</code>.  Thus one can run the first two stages of the toolchain, producing a <code class="highlighter-rouge">.o</code> file for each <code class="highlighter-rouge">.c</code> file, then later use <code class="highlighter-rouge">gcc</code> (again as the overseer) to link them together into a complete executable.</p>

<p>Here’s how I might compile <code class="highlighter-rouge">names</code> in steps.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">cd </span>example/
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>cp ~cs50/public_html/examples/names1.c .
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>cp ~cs50/public_html/examples/readline.[ch] .
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>mygcc -c names1.c
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>mygcc -c readline.c
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>ls
names1.c  names1.o  readline.c	readline.h  readline.o
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>mygcc names1.o readline.o -o names
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>ls
names<span class="k">*</span>	names1.c  names1.o  readline.c	readline.h  readline.o
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>
</code></pre>
</div>

<p>Notice the <code class="highlighter-rouge">-c</code> flag to <code class="highlighter-rouge">mygcc</code> (and thus <code class="highlighter-rouge">gcc</code>).  This tells <code class="highlighter-rouge">gcc</code> not to compile it all the way to a final executable, but to leave the intermediate <code class="highlighter-rouge">.o</code> file in place for later use.</p>

<p>We could use the linker <code class="highlighter-rouge">ld</code> directly, but it was easier to let <code class="highlighter-rouge">gcc</code> oversee that step again, as in the third run of <code class="highlighter-rouge">mygcc</code> above.</p>

<p>Up until now we have been typing out the <code class="highlighter-rouge">gcc</code> command lines to build and executable:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>    gcc -Wall -pedantic -std<span class="o">=</span>c11  
</code></pre>
</div>

<p>or more commonly, with our alias <code class="highlighter-rouge">mygcc</code>:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>    mygcc -o names.c readine.c -o names
</code></pre>
</div>

<p>It’s handy to have this alias.  But as our programs become more complex, we may need to add more command-line switches to <code class="highlighter-rouge">gcc</code>, and we may need to compile many <code class="highlighter-rouge">.c</code> files into <code class="highlighter-rouge">.o</code> files, keep track of which ones to recompile when changed, and write out a series of commands to compile them.  That’s where <code class="highlighter-rouge">make</code> comes in.</p>

<h2 id="the-make-concept">The make concept</h2>

<p>From now on we will use the <code class="highlighter-rouge">make</code> tool to automate the building of software systems.   <code class="highlighter-rouge">make</code> is essentially a command generator. You provide it with a file (by default, called <code class="highlighter-rouge">Makefile</code>) that describes the interdependencies among the files that are used to build a particular <em>target</em>, which is typically an executable. <code class="highlighter-rouge">make</code> builds a dependency tree of all the files that the requested target depends on, determines whether any of the files have changed, and then issues the commands shown in the <code class="highlighter-rouge">Makefile</code> that will bring any dependent files up to date and then update the target itself.  If everything is up to date, <code class="highlighter-rouge">make</code> runs no commands, saving a lot of time.</p>

<blockquote>
  <p>You can view the <a href="http://www.gnu.org/software/make/manual/make.html">GNU documentation</a>, the manual pages for <code class="highlighter-rouge">make</code>, Steve Talbot’s “oldie but goodie” book “<em>Managing projects with make</em>” <a href="http://shop.oreilly.com/product/9780596006105.do">updated</a> in 2004 by Robert Mecklenburg for GNU <code class="highlighter-rouge">make</code>, or any of the variety of online tutorials for <code class="highlighter-rouge">make</code>.</p>
</blockquote>

<p><strong>emacs tip</strong>: if you use emacs, you may want to install a small customation that makes it super-easy to run <code class="highlighter-rouge">make</code> from inside <code class="highlighter-rouge">emacs</code>:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>  cp ~cs50/.emacs ~
</code></pre>
</div>

<p>Whenever you start <code class="highlighter-rouge">emacs, it loads this file. This file defines a new command </code>^X-c<code class="highlighter-rouge">, which tells </code>emacs<code class="highlighter-rouge"> to run </code>make -k` in a separate subwindow.  It’s handy!</p>

<blockquote>
  <p>If <code class="highlighter-rouge">cp</code> warns you about over-writing an existing <code class="highlighter-rouge">.emacs</code> you might want to reconsider - perhaps you’ve customized <code class="highlighter-rouge">emacs</code> before and you should edit your <code class="highlighter-rouge">~/.emacs</code> to include commands from <code class="highlighter-rouge">~cs50/.emacs</code> rather than simply overwriting it!</p>
</blockquote>

<h2 id="makefile-basics">Makefile basics</h2>

<p>A makefile (which is a plain text file that the <code class="highlighter-rouge">make</code> tool interprets, and nearly always called just <code class="highlighter-rouge">Makefile</code>) describes a set of rules that capture the various actions that must be performed to build a target. Targets can be specific files, most commonly an executable, but in principle could be any sort of file. These rules are captured in the makefile that is typically found in the source file directory.  Here’s a simple <a href="/~cs50/examples/names-Makefile1.txt">makefile</a> for the <code class="highlighter-rouge">names</code> program:</p>

<div class="language-make highlighter-rouge"><pre class="highlight"><code><span class="c"># Makefile for 'names' program
#
# David Kotz, April 2016
</span>
<span class="nv">CC</span> <span class="o">=</span> gcc
<span class="nv">CFLAGS</span> <span class="o">=</span> -Wall -pedantic -std<span class="o">=</span>c11 -ggdb

<span class="nl">names</span><span class="o">:</span> <span class="nf">names.o readline.o</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> names.o readline.o -o names 

<span class="nl">names.o</span><span class="o">:</span> <span class="nf">readline.h</span>
<span class="nl">readline.o</span><span class="o">:</span> <span class="nf">readline.h</span>

<span class="nl">clean</span><span class="o">:</span>
	rm -f <span class="k">*</span>~
	rm -f <span class="k">*</span>.o
	rm names
</code></pre>
</div>

<blockquote>
  <p>If you download the file from the link above, please note that the filename should be <code class="highlighter-rouge">Makefile</code>.  I renamed it <code class="highlighter-rouge">names-Makefile1.txt</code> so it would co-exist with other files in the <code class="highlighter-rouge">examples</code> directory, and added <code class="highlighter-rouge">.txt</code> so that your browser would be happy rendering it.  If you want to explore and edit this makefile, on your CS Unix account, skip the browser and just copy it from CS50: <code class="highlighter-rouge">cp ~cs50/public_html/examples/names-Makefile1.txt ./Makefile</code>.</p>
</blockquote>

<p>This makefile is written in a format, really a little language, that will be interpreted by <code class="highlighter-rouge">make</code>. It begins with a comment, as any good code should.</p>

<p>It defines two variables (called ‘macros’ in <code class="highlighter-rouge">make</code>). These particular variable names are well-known to <code class="highlighter-rouge">make</code>. <code class="highlighter-rouge">CC</code> defines the compiler command to be used for compiling C code (here, <code class="highlighter-rouge">gcc</code>), and <code class="highlighter-rouge">CFLAGS</code> defines the flags to be passed to the C compiler (here, the usual switches we had in our <code class="highlighter-rouge">mygcc</code> alias).  The makefile uses these variables <em>explictly</em> (substituting their value with <code class="highlighter-rouge">$(CC)</code> syntax) and <em>implicitly</em> (because <code class="highlighter-rouge">make</code> uses them for implicit compilation rules, as we show below).</p>

<p>After those definitions we see four target specifications: <code class="highlighter-rouge">names</code>, <code class="highlighter-rouge">names.o</code>, <code class="highlighter-rouge">readline.o</code>, and <code class="highlighter-rouge">clean</code>. These words, to the left of the colon <code class="highlighter-rouge">:</code>, are the <em>targets</em> - things that this makefile can produce. After the colon is the list of files or other targets upon which that target “depends”. After that target and dependency line, the following lines <em>that begin with a tab character</em> are executed in order to bring that target “up to date” with respect to those dependencies.  That is, if either file <code class="highlighter-rouge">names.o</code> or <code class="highlighter-rouge">readline.o</code> are newer than the file <code class="highlighter-rouge">names</code>, then <code class="highlighter-rouge">make</code> will run the command</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>  	gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb names.o readline.o -o names 
</code></pre>
</div>

<p>Suppose our current directory includes <code class="highlighter-rouge">names.c</code>, <code class="highlighter-rouge">readline.c</code>, and <code class="highlighter-rouge">Makefile</code>. If you type <code class="highlighter-rouge">make</code> (with no parameters), <code class="highlighter-rouge">make</code> will look for (and find) the file <code class="highlighter-rouge">Makefile</code>, parse its contents, identify the first target listed, and, if it is “out of date”, execute the commands that are specified.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>ls
Makefile  names.c  readline.c  readline.h
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb   -c -o names.o names.c
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb   -c -o readline.o readline.c
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb names.o readline.o -o names 
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>ls
Makefile  names<span class="k">*</span>  names.c  names.o  readline.c	readline.h  readline.o
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>
</code></pre>
</div>

<p>In this case, <code class="highlighter-rouge">names</code> is the first target, and it depends on <code class="highlighter-rouge">names.o</code> and <code class="highlighter-rouge">readline.o</code>.  They don’t exist, so <code class="highlighter-rouge">make</code> needs to build them.  Each is listed as a target, with a dependency on <code class="highlighter-rouge">readline.h</code>… but with no commands provided to rebuild them!</p>

<p>Here’s where <code class="highlighter-rouge">make</code> uses <em>implicit</em> rules.  It has an implicit default rule for building <code class="highlighter-rouge">.o</code> files from <code class="highlighter-rouge">.c</code> files.  This rule, in effect, runs <code class="highlighter-rouge">$(CC) $(CFLAGS) -c -o foo.o foo.c</code> when needing to build <code class="highlighter-rouge">foo.o</code> from <code class="highlighter-rouge">foo.c</code>.  In the output above, you can see that <code class="highlighter-rouge">make</code> indeed did so.</p>

<p>Note that <code class="highlighter-rouge">make</code> left behind those intermediate <code class="highlighter-rouge">.o</code> files.  If we edit one of the C files, only that one file will need to be recompiled.  We can use <code class="highlighter-rouge">touch</code> to pretend that we’ve modified <code class="highlighter-rouge">names.c</code> (though <code class="highlighter-rouge">touch</code> makes no actual changes to the file, it updates the file’s modification date).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>touch names.c
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb   -c -o names.o names.c
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb names.o readline.o -o names 
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>
</code></pre>
</div>

<p>But if we modify <code class="highlighter-rouge">readline.h</code>, we need to rebuild both files because they both depend on it:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>touch <span class="k">*</span>.h
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb   -c -o names.o names.c
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb   -c -o readline.o readline.c
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb names.o readline.o -o names 
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>
</code></pre>
</div>

<p>We could give <code class="highlighter-rouge">make</code> a specific target to build, rather than defaulting to the first-listed target:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make clean
rm -f <span class="k">*</span>~
rm -f <span class="k">*</span>.o
rm names
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>ls
Makefile  names.c  readline.c  readline.h
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>
</code></pre>
</div>

<p>By convention, the <code class="highlighter-rouge">clean</code> target is meant to “clean up” the directory by removing temporary and intermediate files, as well as targets (like <code class="highlighter-rouge">names</code>) that can be rebuilt.  Let’s try another:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make names.o
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb   -c -o names.o names.c
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make names.o
make: <span class="s1">'names.o'</span> is up to date.
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make clean
rm -f <span class="k">*</span>~
rm -f <span class="k">*</span>.o
rm -f names
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make clean
rm -f <span class="k">*</span>~
rm -f <span class="k">*</span>.o
rm -f names
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>
</code></pre>
</div>

<p>We ran <code class="highlighter-rouge">make names.o</code> twice; the first time it built the target, and the second time it realized nothing was needed.  We ran <code class="highlighter-rouge">make clean</code> twice, and it executed the commands both times.  The reason is that the latter does not create any file called <code class="highlighter-rouge">clean</code>, and because it is not there, <code class="highlighter-rouge">make</code> always tries to build it.  This is a “phony target”, and is useful for these kinds of housekeeping.</p>

<h3 id="errors">Errors</h3>

<p>If <code class="highlighter-rouge">make</code> encounters an error while compiling, it stops and does not proceed with the rest of the build.   Let me corrupt one of the C files and see what happens.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span><span class="nb">echo </span>Adding this line is an error. &gt;&gt; readline.c
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>make 
gcc -Wall -pedantic -std<span class="o">=</span>c11 -ggdb   -c -o readline.o readline.c
readline.c:39:1: error: unknown <span class="nb">type </span>name ‘Adding’
 Adding this line is an error.
 ^
readline.c:39:13: error: expected ‘<span class="o">=</span>’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘line’
 Adding this line is an error.
             ^
readline.c:39:13: error: unknown <span class="nb">type </span>name ‘line’
&lt;<span class="nb">builtin</span>&gt;: recipe <span class="k">for </span>target <span class="s1">'readline.o'</span> failed
make: <span class="k">***</span> <span class="o">[</span>readline.o] Error 1
<span class="o">[</span>cs50@flume ~/example]<span class="nv">$ </span>
</code></pre>
</div>

<p>Here, the C compilation step fails and prints its error messages;  <code class="highlighter-rouge">make</code> notices this, prints a message, and exits with error status 1.  It will not proceed to compile other files, or build the overall program.</p>

<h2 id="make-command-usage"><code class="highlighter-rouge">make</code> command usage</h2>

<p>Here are some of the command line arguments you can use with make. See <code class="highlighter-rouge">man make</code>.</p>

<p><code class="highlighter-rouge">-f file</code> use <code class="highlighter-rouge">file</code> instead of default <code class="highlighter-rouge">Makefile</code></p>

<p><code class="highlighter-rouge">-n</code> Determine which commands need to be run, but don’t actually execute any of them, just print them.</p>

<p><code class="highlighter-rouge">-k</code> while a particular target and the things that depend on it might have failed, continue trying to make the other dependencies of these targets anyway.</p>

<h2 id="more-on-macros">More on macros</h2>

<p>Any symbol that is defined in a Makefile like this</p>

<div class="highlighter-rouge"><pre class="highlight"><code>NAME = VALUE
</code></pre>
</div>

<p>is called a macro. Once defined, you can expand them using</p>

<div class="highlighter-rouge"><pre class="highlight"><code>... $(NAME) ...
</code></pre>
</div>

<p>The make utility also provides some useful <a href="http://www.gnu.org/software/make/manual/make.html#Automatic-Variables">automatic variables</a>:</p>

<p><code class="highlighter-rouge">$@</code>   name of the current target</p>

<p><code class="highlighter-rouge">$?</code>   the list of dependencies that are newer than the target</p>

<p><code class="highlighter-rouge">$^</code>	the list of dependencies for this target</p>

<p>For example, we could rewrite our <code class="highlighter-rouge">names</code> target as follows</p>

<div class="language-make highlighter-rouge"><pre class="highlight"><code><span class="nl">names</span><span class="o">:</span> <span class="nf">names.o readline.o</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nv">$^</span> -o <span class="nv">$@</span>
</code></pre>
</div>

<p>Indeed, this is recommended - because then you are not repeating the same information on two lines.  (Such repetition can lead to bugs, if you update one and forget to update the other.)</p>

<p>It is also common to go further in defining the name of the program being built, and the list of object files that go into it.  Below, our final <a href="/~cs50/examples/names-Makefile2.txt">Makefile</a>, we’ve declared <code class="highlighter-rouge">PROG</code> and <code class="highlighter-rouge">OBJS</code> for this purpose, and use them in the build command.  I also included a list of library files needed by this program as <code class="highlighter-rouge">LIBS</code>; although <code class="highlighter-rouge">names</code> does not need the math library, it’s harmless to ask <code class="highlighter-rouge">gcc</code> to link with the math library and it serves as a good example here. (Certain libraries, like stdio and stdlib, are linked without you asking.)</p>

<div class="language-make highlighter-rouge"><pre class="highlight"><code><span class="c"># Makefile for 'names' program
#  (adding more macros and libraries)
#
# David Kotz, April 2016
</span>
<span class="nv">CC</span> <span class="o">=</span> gcc
<span class="nv">CFLAGS</span> <span class="o">=</span> -Wall -pedantic -std<span class="o">=</span>c11 -ggdb
<span class="nv">PROG</span> <span class="o">=</span> names
<span class="nv">OBJS</span> <span class="o">=</span> names.o readline.o
<span class="nv">LIBS</span> <span class="o">=</span> -lm

<span class="nl">$(PROG)</span><span class="o">:</span> <span class="nf">$(OBJS)</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nv">$^</span> <span class="nv">$(LIBS)</span> -o <span class="nv">$@</span>

<span class="nl">names.o</span><span class="o">:</span> <span class="nf">readline.h</span>
<span class="nl">readline.o</span><span class="o">:</span> <span class="nf">readline.h</span>

<span class="nl">clean</span><span class="o">:</span>
	rm -f <span class="k">*</span>~
	rm -f <span class="k">*</span>.o
	rm -f names
</code></pre>
</div>

<h2 id="non-compilation-makefiles">Non-compilation makefiles</h2>

<p>You can use makefiles to solve many of your daily challenges involving a sequences of dependent actions:</p>

<ul>
  <li>running test shell scripts during development and regression testing</li>
  <li>creating documents with LaTeX</li>
  <li>maintaining webpages (staging and live directories)</li>
  <li>automated documentation generation</li>
  <li>source code management</li>
</ul>

<p>Here, for example, here is the Makefile we use to compile and push the CS50 website to the webserver:</p>

<div class="language-make highlighter-rouge"><pre class="highlight"><code><span class="c"># Makefile for deploying Jekyll site.
# David Kotz, Spring 2016, borrowing from Charles Palmer and Ira Jenkins
</span>
<span class="nv">DEST</span><span class="o">=</span>cs50@katahdin.cs.dartmouth.edu:public_html
<span class="nv">DESTURL</span><span class="o">=</span>http://www.cs.dartmouth.edu/~cs50/
<span class="nv">LOCALURL</span><span class="o">=</span>http://127.0.0.1:4000

<span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">build deploy local clean</span>

<span class="c"># just for testing the build
</span><span class="nl">build</span><span class="o">:</span>
	<span class="p">@</span><span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Building..."</span>
	jekyll build

<span class="c"># build and push to CS server
</span><span class="nl">deploy</span><span class="o">:</span>
	cat _config-<span class="o">{</span>base,cs<span class="o">}</span> &gt; _config.yml
	<span class="p">@</span><span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Building for CS..."</span>
	jekyll build --destination _site
	<span class="p">-</span>rm _config.yml

	<span class="err">@echo</span> <span class="s2">"\nFixing permissions..."</span>
	<span class="err">chmod</span> <span class="err">-R</span> <span class="err">go-w</span> <span class="err">_site/*</span>
	<span class="err">chmod</span> <span class="err">-R</span> <span class="err">go+rX</span> <span class="err">_site/*</span>
	<span class="err">@echo</span> <span class="s2">"\nStripping site of do-not-publish items..."</span>
	<span class="err">rm</span> <span class="err">-f</span> <span class="err">_site/Makefile</span>
	<span class="err">find</span> <span class="err">_site</span> <span class="err">-name</span> <span class="err">\*-draft.\*</span> <span class="err">-print0</span> <span class="err">|</span> <span class="err">xargs</span> <span class="err">-0</span> <span class="err">rm</span> <span class="err">-f</span>

	<span class="err">@echo</span> <span class="s2">"\nDeploying..."</span>
	<span class="err">rsync</span> <span class="err">-e</span> <span class="err">ssh</span> <span class="err">--delete</span> <span class="err">-avz</span> <span class="err">_site/</span> <span class="err">$(DEST)</span>
	<span class="err">open</span> <span class="err">$(DESTURL)</span>

<span class="c"># build and open in a local server (jekyll serve runs jekyll build first)
</span><span class="nl">local</span><span class="o">:</span> 
	<span class="p">@</span><span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Building for local viewing..."</span>
	cat _config-<span class="o">{</span>base,local<span class="o">}</span> &gt; _config.yml
	<span class="o">(</span>sleep 4; open <span class="nv">$(LOCALURL)</span><span class="o">)</span> &amp;
	jekyll serve --incremental
	<span class="p">-</span>rm _config.yml

<span class="nl">clean</span><span class="o">:</span>
	jekyll clean
	<span class="p">-</span>rm -rf _config.yml
</code></pre>
</div>

<p>The leading <code class="highlighter-rouge">@</code> on some command lines tells <code class="highlighter-rouge">make</code> not to print that command out for the user to see - just to execute the command.  Here I use it for <code class="highlighter-rouge">echo</code> commands because, of course, those print their arguments for the user to see.</p>

<p>The leading <code class="highlighter-rouge">-</code> on some command lines tells <code class="highlighter-rouge">make</code> to ignore the exit status of that command - so even a non-zero exit status will allow <code class="highlighter-rouge">make</code> to continue and not exit with an error message.</p>

<h2 id="header-files">Header files</h2>

<p><strong><em>Not covered in class, so read on!</em></strong></p>

<p>Let’s look at the contents and purpose of <code class="highlighter-rouge">readline.h</code>.  That file was used in the recent examples:</p>

<ul>
  <li><a href="/~cs50/examples/names1.c">names1.c</a>: arrays of strings, reading and copying lines into an array.</li>
  <li><a href="/~cs50/examples/names2.c">names2.c</a>: scanning a string and truncating it by overwriting a character with the null <code class="highlighter-rouge">\0</code> character.</li>
</ul>

<p>These use</p>

<ul>
  <li><a href="/~cs50/examples/readline.c">readline.c</a>: a C file defining the function <code class="highlighter-rouge">readLine</code>, used by <code class="highlighter-rouge">names*.c</code>.</li>
  <li><a href="/~cs50/examples/readline.h">readline.h</a>: a C ‘header’ file that provides prototypes needed by any C program wanting to use <code class="highlighter-rouge">readLine</code>.</li>
</ul>

<p>Why did we need this include file, <code class="highlighter-rouge">readline.h</code>?  Because we compiled <code class="highlighter-rouge">names.c</code> and <code class="highlighter-rouge">readline.c</code> separately.  When we compiled <code class="highlighter-rouge">names.c</code>, we needed to declare the prototype for the function <code class="highlighter-rouge">readLine</code>, just as we would have if <code class="highlighter-rouge">readLine</code> had been defined within <code class="highlighter-rouge">names.c</code>.  Because the function was <em>not</em> defined within <code class="highlighter-rouge">names.c</code>, though, the prototype needs to be prefixed with <code class="highlighter-rouge">extern</code>, indicating that the function is external to the current C file.  The C compiler leaves that symbol (<code class="highlighter-rouge">readLine</code>) unresolved, and hopes the linker will later be able to connect it to the actual function definition when <code class="highlighter-rouge">names.o</code> is linked with other object files.</p>

<p>We could have simply typed the prototype into <code class="highlighter-rouge">names.c</code>, but we put it in a separate file <code class="highlighter-rouge">header.h</code>, and then used the special compiler directive <code class="highlighter-rouge">#include</code> to literally copy the contents of <code class="highlighter-rouge">header.h</code> into the C file at that point. Just in case the header file gets included multiple times, the pair of directives <code class="highlighter-rouge">#ifndef</code> (if not defined) and <code class="highlighter-rouge">#define</code> (define) ensure the body of this file is only processed once per C file.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 
 * readline.h - a utility function to safely read one line of input
 * See readline.c for documentation.
 *
 * David Kotz, April 2016
 */</span>

<span class="cp">#ifndef __READLINE_H__
#define __READLINE_H__
</span>
<span class="cp">#include &lt;stdbool.h&gt;
</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">readLine</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#endif //  __READLINE_H__
</span></code></pre>
</div>

<p>We also include <code class="highlighter-rouge">header.h</code> in <code class="highlighter-rouge">readline.c</code>.  This way, we write the prototype in only one place, and yet give the compiler information in both places where it is needed - and give the compiler a chance to help us catch any inconsistencies between the prototype and the function call in <code class="highlighter-rouge">names.c</code>, or between the prototype and the function definition in <code class="highlighter-rouge">readline.c</code>.</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">CS50 Summer 2016 -- Dartmouth College</h2>

    <p> <font size=-1> 
    	This version of the course is based upon those designed by 
    	Professors Kotz, Palmer, Campbell, and Balkcom. 
	I am deeply indebted to these outstanding educators.
    -- <a href="/~xia/">Xia Zhou</a>
       </font> 
    </p>

  </div>

</footer>


  </body>

</html>
