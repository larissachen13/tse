http://old-www.cs.dartmouth.edu/~cs50/Lectures/02-shell.html
3
<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lecture 02 - Introduction to Bash</title>
  <meta name="description" content="In Computer Science 50 you will learn how to design & build large,  reliable, maintainable, and understandable software systems.  In the process you will learn to program in C with Unix development tools.
">

  <link rel="stylesheet" href="/~cs50/css/main.css">
  <link rel="canonical" href="http://www.cs.dartmouth.edu/~cs50/Lectures/02-shell.html">
</head>


  <body>

    <header class="site-header">

    <a class="site-title" href="/~cs50/">CS50 Summer 2016</a>

    <nav class="site-nav">

      [<a href="https://canvas.dartmouth.edu/courses/15260">Canvas</a>]
      [<a href="https://piazza.com/dartmouth/summer2016/cs50/home">Piazza</a>]
      [<a href="https://gitlab.cs.dartmouth.edu">Gitlab</a>]
      [<a href="/~cs50/Schedule.pdf">Schedule</a>]
      [<a href="/~cs50/Lectures/">Lectures</a>]
      [<a href="/~cs50/Reading/">Reading</a>]
<!--      [<a href="/~cs50/examples/">Examples</a>]  -->
      [<a href="/~cs50/Logistics/">Logistics</a>]
      [<a href="/~cs50/Resources/">Resources</a>]
      [<a href="/~cs50/Labs/">Labs</a>]
      [<a href="/~cs50/Project/">Project</a>]

   </nav>
</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Lecture 02 - Introduction to Bash</h1>
  </header>

  <div class="post-content">
    <p>In this lecture, we discuss the Unix shell and its commands. The ‘shell’ is a <em>command-line interpreter</em> and invokes kernel-level commands. It also can be used as a <em>programming language</em> to design your own commands. We’ll come to shell programming in a future lecture.</p>

<p>We do not recommend that you buy a Unix book; there are some very good references and free-access online books – see the <a href="/~cs50/Resources">resources page</a> – and we have selected some interesting and useful <a href="/~cs50/Reading">readings</a>.</p>

<p>If you need help on the meaning or syntax of any Unix shell command you can use the manual (man) pages on a Unix system or the <a href="http://www.computerhope.com/unix.htm#04">web unix commands</a>.  Just keep in mind that some commands’ syntax varies a bit across Unix flavors, so when in doubt, check the man page on the system you’re using.</p>

<h2 id="unix-philosophy">Unix Philosophy</h2>

<p>In their book <em>Program Design in the Unix Environment</em>(1984), Rob Pike and Brian Kernighan put it this way:</p>

<blockquote>
  <p>``Much of the power of the Unix operating system comes from a style of program design that makes programs easy to use and, more important, easy to combine with other programs. This style has been called the use of software tools, and depends more on how the programs fit into the programming environment and how they can be used with other programs than on how they are designed internally. […] This style was based on the use of tools: using programs separately or in combination to get a job done, rather than doing it by hand, by monolithic self-sufficient subsystems, or by special-purpose, one-time programs.’’</p>
</blockquote>

<p>Here’s a quote from our very own <a href="http://web.cs.dartmouth.edu/people/douglas-mcilroy">Doug McIlroy</a>:</p>

<blockquote>
  <p>``This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.’’
— Doug McIlroy</p>
</blockquote>

<h2 id="goals">Goals</h2>

<p>We plan to cover the following topics in today’s lecture:</p>

<ul>
  <li>The <code class="highlighter-rouge">man</code> pages</li>
  <li>The shell</li>
  <li>The file system</li>
</ul>

<h2 id="navigating-within-man-pages">Navigating within man pages</h2>

<p>You may have found the <code class="highlighter-rouge">man</code> system to be a little challenging to navigate. There is a message that is displayed at the very bottom of the screen when you first enter the command that you might have missed (most people do):</p>

<pre><code class="language-man">Manual page xxx(n) line 1 (press h for help or q to quit)
</code></pre>

<p>If you enter ‘<code class="highlighter-rouge">h</code>’ to see the help you will find many more commands than you’re likely to ever use when reading <code class="highlighter-rouge">man</code> pages. This is because the man-page reader is actually the <code class="highlighter-rouge">less</code> command of Unix. I tend to use only a few:</p>

<ul>
  <li><code class="highlighter-rouge">f</code> or <em>space</em> (the spacebar) advances to the next screenful,</li>
  <li><code class="highlighter-rouge">b</code> goes back to the previous screenful,</li>
  <li><code class="highlighter-rouge">e</code> or down-arrow advances one more line,</li>
  <li><code class="highlighter-rouge">y</code> or up-arrow goes back one line,</li>
  <li><code class="highlighter-rouge">/</code> allows one to type a search phrase and hit return,</li>
  <li><code class="highlighter-rouge">q</code> quits <code class="highlighter-rouge">man</code>, and returns to the shell prompt.</li>
</ul>

<h2 id="viewing-files">Viewing files</h2>

<p>Less Is More: The  <code class="highlighter-rouge">less</code> and <code class="highlighter-rouge">more</code> commands are handy for quickly looking at files. The syntax is <code class="highlighter-rouge">less filename</code> and <code class="highlighter-rouge">more filename</code>. Take a look at the <code class="highlighter-rouge">man</code> pages to get the details of each. Similarly, <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">tail</code> display a number of lines (selectable via switches, of course) at the beginning and end of a file, respectively.</p>

<p>See what these do: <code class="highlighter-rouge">cat /etc/passwd</code>, <code class="highlighter-rouge">head /etc/passwd</code>, <code class="highlighter-rouge">tail /etc/passwd</code>, <code class="highlighter-rouge">more /etc/passwd</code>, and <code class="highlighter-rouge">less /etc/passwd</code>.  The file <code class="highlighter-rouge">/etc/passwd</code> lists all the accounts on the system, and information about each account.</p>

<h2 id="locating-files">Locating files</h2>

<p>Many times you want to find a file but do not know where it is in the directory tree (Unix directory structure is a tree - rooted at the <code class="highlighter-rouge">/</code> directory) . The <code class="highlighter-rouge">find</code> command can walk a file hierarchy:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>find . -name DougMcIlroy.pdf -print
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>find public_html -iname reading -print
public_html/Reading
./public_html/Resources/DougMcIlroy.pdf
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>find public_html -type d -print
public_html
public_html/Logistics
public_html/Resources
public_html/Labs
public_html/Project
public_html/Lectures
public_html/css
public_html/Reading
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>find public_html -name <span class="se">\*</span>.html -print
public_html/Logistics/index.html
public_html/Resources/index.html
public_html/Resources/Homebrew.html
public_html/Labs/index.html
public_html/Labs/Lab0-Preliminaries.html
public_html/Project/index.html
public_html/Lectures/01-gettingstarted.html
public_html/Lectures/index.html
public_html/index.html
public_html/Reading/index.html
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>find public_html -name <span class="se">\*</span>.png -mtime -1 -print
public_html/Resources/Homebrew1.png
public_html/Resources/Homebrew0.png
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>The first example searches directory <code class="highlighter-rouge">.</code> to find a file by a specific name and prints its pathname. 
The second example used <code class="highlighter-rouge">-iname</code> (case insensitive search) instead of <code class="highlighter-rouge">-name</code> (which is case sensitive) to search <code class="highlighter-rouge">public_html</code> for the “reading” directory.
The third example searches <code class="highlighter-rouge">public_html</code> for any directories (<code class="highlighter-rouge">-type d</code>) and prints their pathnames.
The fourth example uses a wildcard <code class="highlighter-rouge">*</code> to print pathnames of files whose name matches a pattern; the backslash <code class="highlighter-rouge">\</code> is there to prevent the shell from interpreting the <code class="highlighter-rouge">*</code>, allowing it to be part of the argument to <code class="highlighter-rouge">find</code>, which interprets that character itself.
The fifth example combines two factors, to print pathnames of files whose name matches <code class="highlighter-rouge">*.png</code> and whose modication time <code class="highlighter-rouge">mtime</code> is less than one day <code class="highlighter-rouge">-1</code> in the past.</p>

<p><strong>file</strong>: Many times you are not sure what the contents of a file is: it could be text, binary, compressed, specific format to a certain application. In this case the <code class="highlighter-rouge">file</code> command is very useful. Below we can decode what the files are - some are obvious from their names others are not. Sometimes there is a disconnect between a file name (e.g., <code class="highlighter-rouge">trash.tar.gz</code>) and the application fails to realize that the name does not accurately describe the contents. In this case it’s always better to check.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>file downloaded  
downloaded: POSIX tar archive
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>file fig1  
fig1: GIF image data, version 87a, 440 x 306
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>file trash.tar.gz  
trash.tar.gz: gzip compressed data, from Unix
</code></pre>
</div>

<h2 id="the-shell">The shell</h2>

<h3 id="commands-switches-arguments">Commands, switches, arguments</h3>

<p>The shell is the Unix command-line interpreter. It provides an interface between the user and the kernel and executes programs called ‘commands’. For example, if a user enters <code class="highlighter-rouge">ls </code>then the shell executes the <code class="highlighter-rouge">ls</code> command, which actually executes a program stored in the file <code class="highlighter-rouge">/bin/ls</code>. The shell can also execute other programs including scripts (text files interpreted by a program like python or bash) and compiled programs (e.g., written in C).  Even your own programs – once marked ‘executable’ – become commands you can run from the shell!</p>

<p>You will get by in the course by becoming familiar with a subset of the Unix commands; don’t let yourself be overwhelmed by the presence of hundreds of commands. You will probably be regularly using 2-3 dozen of them by the end of the term.</p>

<p>Unix has often been criticized for being very terse (it’s rumored that its designers were bad typists). Many commands have short, cryptic names and vowels are a rarity:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>awk, cat, cp, cd, chmod, echo, find, grep, ls, mv, ps, rm, sed
</code></pre>
</div>

<p>We will learn to use all of these commands and more.</p>

<p>Unix command output is also very terse - the default action on success is silence. Only errors are reported, and then sometimes the error message is also terse, as in <code class="highlighter-rouge">?</code>. Unix strongly supports the philosophy of one and only one way to perform each task. Unix commands are often termed ‘tools’ or ‘utilities’, because they are meant to be simple tools that you can combine in novel ways.</p>

<p>Instructions entered in response to the shell prompt have the following syntax:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>    <span class="nb">command</span> <span class="o">[</span>arg1] <span class="o">[</span>arg2] ... <span class="o">[</span>argn]
</code></pre>
</div>

<p>The brackets <code class="highlighter-rouge">[ ]</code> indicate that the arguments are optional. Many commands can be executed with or without arguments. Others require arguments, or a certain number of arguments, (e.g., <code class="highlighter-rouge">cp sort.c anothersort.c</code>) to work correctly. If none are supplied, they will provide some error message in return. Another part of the Unix philosophy is to avoid an explosion in the number of commands by having most commands support various options, or switches, which modify the actions of the commands.</p>

<p>For example, let’s use the <code class="highlighter-rouge">ls</code> command and the <code class="highlighter-rouge">-l</code> option switch to list in long format the file <code class="highlighter-rouge">filename.c</code>.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>    ls -l filename.c
</code></pre>
</div>

<p>Switches are often single characters preceded by a hyphen (e.g., <code class="highlighter-rouge">-l</code>). Most commands accept switches in any order, though they generally must appear before all ‘true’ arguments (usually filenames). In the case of the <code class="highlighter-rouge">ls</code> example below, the command arguments represent [options] filenames[s]. The options modify the operation of the command and are usually operated on by the program invoked by the shell rather than the shell itself. (Note: an exception to this is when the options include environment variables like <code class="highlighter-rouge">$USER</code> which the shell would replace with the username of the currently logged in user.)</p>

<p>Unix programs always receive a list of arguments, containing at least one argument, which is always the command name itself. So, for <code class="highlighter-rouge">ls</code> that first argument would be “<code class="highlighter-rouge">ls</code>”. The first argument is referred to as argument 0, “the zero-th argument”. In our <code class="highlighter-rouge">ls</code> example, argument 1 is <code class="highlighter-rouge">-l</code> and argument 2 is  <code class="highlighter-rouge">filename.c</code>.  Some commands also accept their switches grouped together. For example, the following switches to <code class="highlighter-rouge">ls</code> are identical:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>    ls -tla foople<span class="k">*</span>
    ...
    ls -t -l -a foople<span class="k">*</span>
</code></pre>
</div>

<p>The shell parses the words or tokens (commandname, options, filesnames[s]) you type on the command line, and asks the kernel to execute the program corresponding to that command; the interpretation of the arguments (whether switches, filenames, or something else) is determined by that program.</p>

<p>Typically, the shell processes the complete line after a carriage return is entered and then goes off to find the program that the command line specified. If the command is a pathname, whether relative (e.g., <code class="highlighter-rouge">./mycommand</code>) or absolute (e.g., <code class="highlighter-rouge">/net/class/cs50/mycommand</code>), the shell simply executes the program in that file.  If the command is not a pathname, the shell searches through a list of directories in your “path”, which is defined by the shell variable called <code class="highlighter-rouge">PATH</code>.</p>

<h2 id="shells-path">Shell’s ‘Path’</h2>

<p>Take a look at your <code class="highlighter-rouge">PATH</code> by asking the shell to substitute its value (<code class="highlighter-rouge">$PATH</code>) and pass it as an argument to the <code class="highlighter-rouge">echo</code> command:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>                                              
/net/class/cs50/bin:/usr/ucb:/usr/local/bin:/bin:/usr/bin:/usr/local:/usr/sbin:/sbin:/usr/bsd:/usr/contrib/bin:/usr/bin/X11:/usr/local/bin/X11
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>So where does the <code class="highlighter-rouge">ls</code> command executed above reside in the Unix directory hierarchy? Let`s use another command to find out.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>which ls
ls is aliased to <span class="sb">`</span>ls -F<span class="s1">'
ls is /bin/ls
ls is /usr/bin/ls
[cs50@flume ~]$ 
</span></code></pre>
</div>

<p>The first line of response says that <code class="highlighter-rouge">ls</code> is “aliased”.  This is a shell feature; the shell allows us to define “aliases”, which act just like commands but are actually just a textual substitution of a command name (the alias) to some other string (in this case, <code class="highlighter-rouge">ls -F</code>).  Thus, any time I type <code class="highlighter-rouge">ls blah blah</code>, it treats it as if I had typed <code class="highlighter-rouge">ls -F blah blah</code>.  The <code class="highlighter-rouge">-F</code> option tells <code class="highlighter-rouge">ls</code> to add a trailing symbol to some names in its output; it adds a <code class="highlighter-rouge">/</code> to the names of directories, a <code class="highlighter-rouge">@</code> to the names of symbolic links (um, that’s another conversation), and some other even specialized cases.</p>

<p>Of course, the shell then still needs to resolve <code class="highlighter-rouge">ls</code>.  It then searches the <code class="highlighter-rouge">PATH</code> to find an executable file with that name; in this case, it appears that <code class="highlighter-rouge">ls</code> exists in both <code class="highlighter-rouge">/bin</code> and in <code class="highlighter-rouge">/usr/bin</code>.  The shell will execute the first one, because it is found first.  Below you can see the effect of running <code class="highlighter-rouge">ls</code> (the alias) and <code class="highlighter-rouge">/bin/ls</code> (the raw command, without the <code class="highlighter-rouge">-F</code>).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls
Archive/  private/  proc-log  public_html/  resources/	web@
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>/bin/ls
Archive  private  proc-log  public_html  resources  web
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<h3 id="there-are-shells-shells-and-more-shells">There are shells, shells, and more shells</h3>

<p>There are a number of shells available to a Unix user – so which one do you select? The most common shells are:</p>

<ul>
  <li><code class="highlighter-rouge">sh</code> : the original shell, known as the Bourne Shell,</li>
  <li><code class="highlighter-rouge">csh</code>, <code class="highlighter-rouge">tcsh</code> : well-known and widely used derivatives of the Bourne shell,</li>
  <li><code class="highlighter-rouge">ksh</code> : the Korn shell, and</li>
  <li><code class="highlighter-rouge">bash</code> : the Bourne Again SHell, developed by GNU, is the most popular shell used for Linux.</li>
</ul>

<p><code class="highlighter-rouge">bash</code> is the default shell for new Unix accounts in our department.</p>

<p>The basic shell operation is as follows. The shell parses the command line; the first word on the line is the command name.  If the command is an alias, it substitutes the alias text and again identifies the command.  If the command is one built-in to the shell (there are a few, like <code class="highlighter-rouge">cd</code>, <code class="highlighter-rouge">echo</code>, <code class="highlighter-rouge">pwd</code>, and <code class="highlighter-rouge">which</code>) it performs that command’s action.  Otherwise, the shell looks for the executable file that matches that program name by searching directories listed in the <code class="highlighter-rouge">PATH</code> variable. The shell then starts that program as a new process and passes any options and arguments to the program.  A <em>process</em> is a running program.  You can see a list of your processes with the command <code class="highlighter-rouge">ps</code>.</p>

<h2 id="unix-file-system">Unix file system</h2>

<p>The Unix file system is a <em>hierarchical file system</em>. The file system consists of a very small number of different file <em>types</em>.  The two most common types are <em>files</em> and <em>directories</em>.  (We won’t talk much about the two other types, <em>character special files</em> and <em>block special files</em>.)</p>

<p>A directory (akin to a folder on a MacOS or Windows computer) contains the names and locations of all files and directories below it. A directory always contains two special files <code class="highlighter-rouge">.</code> (dot) and <code class="highlighter-rouge">..</code> (dot dot); <code class="highlighter-rouge">.</code> represents the directory itself, and <code class="highlighter-rouge">..</code> represents the directory’s parent.  In the following, I make a new directory, change my current working directory to be that new directory, create a new file in that directory, and use <code class="highlighter-rouge">ls</code> to explore the contents of the new directory and its parent.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>mkdir <span class="nb">test</span>
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">cd test</span>
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span><span class="nb">echo </span>hello &gt; somefile
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span>ls -a
./  ../  somefile
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span>ls 
somefile
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span>ls .
somefile
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span>ls ..
Archive/  private/  proc-log  public_html/  resources/	<span class="nb">test</span>/  web@
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span>
</code></pre>
</div>

<p>Directory names are separated by a <em>forward</em> slash <code class="highlighter-rouge">/</code>, forming pathnames.  A <em>pathname</em> is a filename that includes some or all of the directories leading to the file; an <em>absolute pathname</em> is relative to the root (<code class="highlighter-rouge">/</code>) directory and begins with a <code class="highlighter-rouge">/</code>, in the first example below, whereas a <em>relative pathname</em> is relative to the current working directory, as in the second example below.  Notice that a relative pathname can also use <code class="highlighter-rouge">.</code> or <code class="highlighter-rouge">..</code>, as in the third example below.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls /net/class/cs50/public_html/Labs/<span class="k">*</span>
/net/class/cs50/public_html/Labs/index.html
/net/class/cs50/public_html/Labs/Lab0-Preliminaries.html
/net/class/cs50/public_html/Labs/usernames.txt
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls public_html/Resources/<span class="k">*</span>
public_html/Resources/DougMcIlroy.pdf
public_html/Resources/Homebrew0.png
public_html/Resources/Homebrew1.png
public_html/Resources/Homebrew.html
public_html/Resources/index.html
public_html/Resources/RC13972-C-Programming.docx
public_html/Resources/RC13972-C-Programming.pdf
public_html/Resources/StartingSublime.pdf
public_html/Resources/toomey-unix.pdf
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls ../cs10/public_html/
azul.css    help.html	   lab/       oldindex.html  software.html
exams/	    indexBAK.html  lectures/  sa/	     syllabus.html
exams.html  index.html	   old/       schedule.html
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>As implied by the shell prompt, the current working directory is <code class="highlighter-rouge">~cs50</code>, that is, <code class="highlighter-rouge">/net/class/cs50</code>.</p>

<h3 id="moving-around-the-file-system">Moving around the file system</h3>

<p>The “change directory” command (<code class="highlighter-rouge">cd</code>) allows us to move around the Unix directory hierarchy, that is, to change our “current working directory” from which all relative filenames and pathnames will be resolved. Let’s combine <code class="highlighter-rouge">pwd</code>, <code class="highlighter-rouge">ls</code>, and <code class="highlighter-rouge">cd</code> to move around the local directories that are rooted at <code class="highlighter-rouge">/net/class/cs50</code>.  Remember that <code class="highlighter-rouge">~</code> refers to the home directory and <code class="highlighter-rouge">..</code> refers to the parent directory.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>mkdir <span class="nb">test</span>
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">cd test</span>
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span>ls
<span class="o">[</span>cs50@flume ~/test]<span class="nv">$ </span><span class="nb">cd</span> ..
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">cd </span>public_html/
<span class="o">[</span>cs50@flume ~/public_html]<span class="nv">$ </span>ls
css/	    Labs/      Logistics/  Reading/    Schedule.pdf
index.html  Lectures/  Project/    Resources/  Schedule.xlsx
<span class="o">[</span>cs50@flume ~/public_html]<span class="nv">$ </span><span class="nb">cd </span>Resources/
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls
DougMcIlroy.pdf  Homebrew.html		     RC13972-C-Programming.pdf
Homebrew0.png	 index.html		     StartingSublime.pdf
Homebrew1.png	 RC13972-C-Programming.docx  toomey-unix.pdf
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span><span class="nb">cd</span> ../..
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls
Archive/  private/  proc-log  public_html/  resources/	<span class="nb">test</span>/  web@
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>The shell prompt is helpfully tracking the current working directory as we move.</p>

<h3 id="listing-and-globbing-files">Listing and globbing files</h3>

<p>Here are a popular set of switches you can use with <code class="highlighter-rouge">ls</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-l list in long format (as we have been doing)  
-a list all entries (including `dot` files, which are normally hidden)  
-t sort by modification time (latest first)  
-r list in reverse order (alphabetical or time)  
-R list the directory and its subdirectories recursively
</code></pre>
</div>

<p>The shell also interprets certain special characters like <code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">?</code>, and <code class="highlighter-rouge">[]</code>; <code class="highlighter-rouge">*</code> matches zero or more characters, <code class="highlighter-rouge">?</code> matches one character, and <code class="highlighter-rouge">[]</code> matches one character from the set (or range) of characters listed within the brackets:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span><span class="nb">cd </span>public_html/Resources/
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls
DougMcIlroy.pdf  Homebrew.html		     RC13972-C-Programming.pdf
Homebrew0.png	 index.html		     StartingSublime.pdf
Homebrew1.png	 RC13972-C-Programming.docx  toomey-unix.pdf
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls <span class="k">*</span>.pdf
DougMcIlroy.pdf		   StartingSublime.pdf
RC13972-C-Programming.pdf  toomey-unix.pdf
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls H<span class="k">*</span>
Homebrew0.png  Homebrew1.png  Homebrew.html
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls <span class="k">*</span>-<span class="k">*</span>
RC13972-C-Programming.docx  RC13972-C-Programming.pdf  toomey-unix.pdf
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls Homebrew<span class="k">*</span>.<span class="k">*</span>
Homebrew0.png  Homebrew1.png  Homebrew.html
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls Homebrew?.<span class="k">*</span>
Homebrew0.png  Homebrew1.png
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>ls Homebrew[0-9].png
Homebrew0.png  Homebrew1.png
<span class="o">[</span>cs50@flume ~/public_html/Resources]<span class="nv">$ </span>
</code></pre>
</div>

<h3 id="hidden-files">Hidden files</h3>
<p>The <code class="highlighter-rouge">ls</code> program normally does not list any files whose filename begins with <code class="highlighter-rouge">.</code>  There is nothing special about these files, except <code class="highlighter-rouge">.</code> and <code class="highlighter-rouge">..</code>, as far as Unix is concerned.  It’s simply a convention - files whose names begin with <code class="highlighter-rouge">.</code> are to be considered ‘hidden’, and thus not listed by <code class="highlighter-rouge">ls</code> or matched with by the shell’s <code class="highlighter-rouge">*</code> globbing character.  Home directories, in particular, include many ‘hidden’ (but important!) files. 
The <code class="highlighter-rouge">-a</code> switch tells <code class="highlighter-rouge">ls</code> to list “all” files, including those that begin with a dot (aka, the hidden files).</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls
Archive/  private/  public_html/  resources/  web@
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls -a
./   Archive/	    .bash_logout   .bashrc    .environset  private/	public_html/  .ssh/  .viminfo  web@
../  .bash_history  .bash_profile  .emacs.d/  .forward	   .procmailrc	resources/    .vim/  .vimrc
</code></pre>
</div>

<p>to see just the dot files, let’s get clever with the shell’s glob characters:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>ls -ad .??<span class="k">*</span>
.bash_history  .bash_profile  .emacs.d/    .forward	.ssh/  .viminfo
.bash_logout   .bashrc	      .environset  .procmailrc	.vim/  .vimrc
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>All of these “dot files” (or “dot directories”) are important to one program or another:</p>

<ul>
  <li><code class="highlighter-rouge">.bash_history</code> - used by bash to record a history of the commands you’ve typed</li>
  <li><code class="highlighter-rouge">.bash_logout</code> - executed by bash when you log out</li>
  <li><code class="highlighter-rouge">.bash_profile</code> - executed by bash when you log in</li>
  <li><code class="highlighter-rouge">.bashrc</code> - executed by bash whenever you start a new shell</li>
  <li><code class="highlighter-rouge">.emacs.d/</code> - a directory used by emacs text editor</li>
  <li><code class="highlighter-rouge">.environset</code> - a Dartmouth-specific thing; read by .bashrc</li>
  <li><code class="highlighter-rouge">.forward</code> - tells Mail where to forwad your email</li>
  <li><code class="highlighter-rouge">.procmailrc</code> - for handling email with <code class="highlighter-rouge">procmail</code></li>
  <li><code class="highlighter-rouge">.ssh/</code> - directory used by inbound ssh connections</li>
  <li><code class="highlighter-rouge">.vim/</code> - a directory used by vim text editor</li>
  <li><code class="highlighter-rouge">.viminfo</code> - used by vim text editor</li>
  <li><code class="highlighter-rouge">.vimrc</code> - used by vim text editor</li>
</ul>

<h3 id="bash-shell-startup-files">Bash shell startup files</h3>

<p>The <code class="highlighter-rouge">bash</code> shell looks for several files in your home directory:</p>

<ul>
  <li><code class="highlighter-rouge">.bash_profile</code> - executed by bash when you log in</li>
  <li><code class="highlighter-rouge">.bashrc</code> - executed by bash whenever you start a new shell</li>
  <li><code class="highlighter-rouge">.bash_logout</code> - executed by bash when you log out</li>
  <li><code class="highlighter-rouge">.bash_history</code> - used by bash to record a history of the commands you’ve typed</li>
</ul>

<p>The <code class="highlighter-rouge">.bashrc</code> file is especially important, because <code class="highlighter-rouge">bash</code> reads it every time you start a new <code class="highlighter-rouge">bash</code> shell, that is, when you log in, when you start a new interactive shell, or when you run a new bash script. (In contrast, <code class="highlighter-rouge">.bash_profile</code> is only read when you login.)  In each case,<code class="highlighter-rouge">bash</code> reads the files and executes the commands therein.  Thus, you can configure your <code class="highlighter-rouge">bash</code> experience by having it declare some variables, define some aliases, and set up some personal favorites.</p>

<p>Let’s print something at the beginning of each file, like <code class="highlighter-rouge">echo bashrc!</code> at the start of <code class="highlighter-rouge">.bashrc</code>, and see what happens.
<code class="highlighter-rouge">bash
[cs50@flume ~]$ emacs .bash_profile .bashrc
[cs50@flume ~]$ bash
bashrc!
[cs50@flume ~]$ exit
</code></p>

<p>(Don’t forget to remove that silly edit.)</p>

<p>The default <code class="highlighter-rouge">.bashrc</code> file is pretty good, and actually reads a centralized “master” <code class="highlighter-rouge">bashrc</code> managed by our sysadmin.  For CS50 we strongly recommend the following customizations:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="c"># aliases used for cs50</span>

<span class="nb">alias </span><span class="nv">mygcc</span><span class="o">=</span><span class="s1">'gcc -Wall -pedantic -std=c11 -ggdb'</span>

<span class="c"># safety aliases</span>
<span class="nb">alias </span><span class="nv">rm</span><span class="o">=</span><span class="s1">'rm -i'</span>
<span class="nb">alias </span><span class="nv">cp</span><span class="o">=</span><span class="s1">'cp -i'</span>
<span class="nb">alias </span><span class="nv">mv</span><span class="o">=</span><span class="s1">'mv -i'</span>

<span class="c"># convenience aliases</span>
<span class="nb">alias </span><span class="nv">ls</span><span class="o">=</span><span class="s1">'ls -F'</span>
<span class="nb">alias </span><span class="nv">mkdir</span><span class="o">=</span><span class="s1">'mkdir -p'</span>
<span class="nb">alias </span><span class="nv">which</span><span class="o">=</span><span class="s1">'type -all'</span>
<span class="nb">alias </span><span class="nv">du</span><span class="o">=</span><span class="s1">'du -kh'</span>
<span class="nb">alias </span><span class="nv">df</span><span class="o">=</span><span class="s1">'df -kTh'</span>

<span class="c"># --------------------------------------------------------------------</span>
<span class="c"># Set PS1 prompt</span>
<span class="c"># \u: userid, \h:hostname, \w: pwd</span>
<span class="c">#</span>
<span class="nb">export </span><span class="nv">PS1</span><span class="o">=</span><span class="s1">'[\u@\h \w]\$ '</span>
<span class="c">#</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">mygcc</code> alias adds some extra options to <code class="highlighter-rouge">gcc</code>, which we’ll cover next week.</p>

<p>The “safety” aliases protect you from accidentally deleting or overwriting files.</p>

<p>The “convenience” aliases give you some handy shortcuts and make the output of some commands more useful.</p>

<p>Finally, the <code class="highlighter-rouge">PS1</code> definition formats the shell prompt the way we’ve been seeing it in our examples.</p>

<p>To make all these changes in your <code class="highlighter-rouge">.bashrc</code>, log into your Unix account and copy the <code class="highlighter-rouge">.bashrc</code> from the cs50 account:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>cp ~cs50/.bashrc .bashrc
cp: overwrite ‘.bashrc’? y
<span class="o">[</span>cs50@flume ~]<span class="nv">$ </span>
</code></pre>
</div>

<p>You can then edit <code class="highlighter-rouge">~/.bashrc</code> and <code class="highlighter-rouge">~/.bash_profile</code> to your own taste.</p>

<h1 id="historical-note">Historical note</h1>

<p>The name “Terminal” is still commonly used in Unix parlance, right down to the MacOS app by that name.  This term refers to the fact that early Unix computers, like other computers of its time, had a small number of interactive ‘terminals’ connected to it – each directly connected by a dedicated wire to a card within the computer.  Each terminal was little more than a keyboard and a screen - or in the early days, a keyboard and a printer that would print each character as it was typed, and print the characters sent by the computer.</p>

<p>The first such terminals were “teletypes”, adapted from the device used by newsrooms around the country, which printed characters transmitted over the phone line from a distant device. This <a href="https://www.youtube.com/watch?v=ObgXrIYKQjc">video</a> shows a Teletype model ASR33 with a paper-tape reader; at 2:15 you can see how fast this thing can read a paper tape and print! :-)  From the sound of this machine, can you tell why television news shows’ opening music usually has a stocatto tap-tap-tap-tap-tap background theme?</p>

<blockquote>
  <p>One of the first interactive computer systems I ever used was a PDP8/e running ETOS and BASIC - far simpler than Unix - with a couple of teletype terminals.  I found a <a href="https://www.youtube.com/watch?v=2B-U-5ylvWo">video of a refurbished PDP8/e driving a teletype</a>.  Fun.</p>
</blockquote>

<p><strong>It was <em>at Dartmouth</em> that a teletype was actually used to interact with a remote computer</strong> - the first ever long-distance terminal, decades before the Internet.  <em>Scavenger hunt! Who can find the plaque below, on the Dartmouth campus? Post to Piazza when you find it!</em></p>

<p><img src="history-Stibitz1.jpg" alt="Stibitz plaque" /></p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">CS50 Summer 2016 -- Dartmouth College</h2>

    <p> <font size=-1> 
    	This version of the course is based upon those designed by 
    	Professors Kotz, Palmer, Campbell, and Balkcom. 
	I am deeply indebted to these outstanding educators.
    -- <a href="/~xia/">Xia Zhou</a>
       </font> 
    </p>

  </div>

</footer>


  </body>

</html>
